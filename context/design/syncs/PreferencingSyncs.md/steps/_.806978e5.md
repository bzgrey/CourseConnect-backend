---
timestamp: 'Tue Dec 02 2025 11:04:51 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251202_110451.4793aa23.md]]'
content_id: 806978e53024811ee43aefc5803bd4c4733bbbf02ba075020ca0195cda014f6f
---

# Common Pitfalls

Synchronizations are in some ways a reflection of the underlying cause-and-effect structure of your application. Here are a few common issues that can occur while programming with synchronizations, especially when you might miss a few edge cases.

## Zero Matches

Usually occurring with a `where` clause in which you are looking for an array or multiple matches, there's the possibility that your queries return no frames at all. What happens then? Since the then occurs for each frame, this means **the synchronization does not fire at all**. In the sample app, ConceptBox, there was initially a synchronization for returning all files that looked like this:

```typescript
export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // frames = [] if no files uploaded yet!
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

However, this would always timeout and not respond if there were no files uploaded yet. Instead, a general pattern to fix this is to be explicit about your default return value, as follows:

```typescript
import { actions, Frames, Sync } from "@engine";
import { Requesting, Sessioning, FileUploading, Sharing } from "@concepts";

export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    // Make sure to grab the original frame to return to the response
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // Explicitly check if frames are empty
    if (frames.length === 0) {
      // Then join the original frame with whatever result variables you need
      const response = {...originalFrame, [results]: []}
      // Note the additional import `Frames` available from @engine 
      return new Frames(response)
    }
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

There are only two minor additions:

1. Grabbing the original frame, as the `then` clause needs other bindings.
2. Checking for whatever empty condition you may have, then adding any binding you may need for results.

## Missing actionId in `then` clause

This is an error you may occasionally encounter with malformed synchronizations, particularly in the `where` clause. It occurs primarily for two reasons:

1. Your `where` function is not properly returning a set of Frames. Make sure that the function is labeled as `async`, and that you await each call to `.query`.
2. Your frame is missing other bindings, meaning you manually created a new frame or didn't join with an original frame. See the previous example for a nice pattern to do this when you want to form an entirely new frame.

* **concept**: Preferencing \[User, Item]

* **purpose**: To allow a user to assign a personal numerical score to a single item at a time, and to query this score.

* **principle**: Each user can assign a score to at most one item at any given time. Assigning a score to an item (either new or existing) replaces any previously held item and score for that user.

* **state**:
  * A set of `Users` with
    * an `item` of type `Item`
    * a `score` of type `Number`

* **actions**:
  * `addScore (user: User, item: Item, score: Number)`
    * **requires**: The `user` must not currently have an `item` and `score` assigned. The `score` must be a valid number.
    * **effects**: Assigns the given `item` and `score` to the `user`.
  * `updateScore (user: User, item: Item, score: Number)`
    * **requires**: The `user` must already have the specified `item` assigned. The `score` must be a valid number.
    * **effects**: Updates the `score` for the `user`'s assigned `item` to the new value.
  * `removeScore (user: User, item: Item)`
    * **requires**: The `user` must have the specified `item` assigned to them.
    * **effects**: Clears the `item` and `score` from the `user`'s record, removing the preference.

* **queries**:
  * `_getScore (user: User, item: Item): (score: Number)`
    * **requires**: `user` exists and `item` is associated with `user`
    * **outputs**: return `score` associated with `item`

  * `_getAllItems(user: User): (items: Item[])`
    * **requires** `user` exists
    * **effects**: list of Item `items` associated with the `user` is returned

- **concept**: Friending \[User]

- **purpose**: To manage mutual, consent-based social connections between users, and allow mutual friends to see each other's schedules.

- **principle**: If User A sends a friend request to User B, and User B accepts the request, then User A and User B will appear on each other's friends list. And they
  will be able to see each others schedules.

- **state**:
  `pendingRequests: a set of (requester: User, requestee: User)`
  `friends: a set of {user1: User, user2: User}` (a symmetric relationship)

- **actions**:
  `requestFriend (requester: User, requestee: User)`
  **requires** `requester` and `requestee` are not already friends. A pending request from `requester` to `requestee` does not already exist. `requester` is not `requestee`.
  **effects** Adds the pair (`requester`, `requestee`) to the `pendingRequests` set.

  `acceptFriend (requester: User, requestee: User)`
  **requires** A pending request from `requester` to `requestee` exists in pendingRequests.
  **effects** Removes the pair (`requester`, `requestee`) from `pendingRequests`. Adds the pair `{requester, requestee}` to the `friends` set.

  `rejectFriend (requester: User, requestee: User)`
  **requires** A pending request from `requester` to `requestee` exists in pendingRequests.
  **effects** Removes the pair (`requester`, `requestee`) from `pendingRequests`.

  `removeFriend (remover: User, removed: User)`
  **requires** `remover` and `removed` are friends.
  **effects** Removes the pair `{remover, removed}` from the `friends` set.

- **queries**
  `_getAllIncomingFriendRequests (user:User): (requestee: User)[]`
  **effects** returns list of requestees for user (requests where user is the requester)

  `_getAllOutgoingFriendRequests (user:User): (requester: User)[]`
  **effects** returns list of requesters for user (requests where user is the requestee)

  `_getAllFriends (user:User):User[]`
  **effects** returns list of friends for user

  `_areTheyFriends(user1:User, user2:User): Boolean`
  **effects** returns true if {user1, user2} exists in friends otherwise false

* **concept**: Blocking \[User]
* **purpose**: To empower users to prevent specific individuals from viewing their information, even if they are in a shared group or context.
* **principle**: If User A blocks User B, then even if they are both members of the same group, any application feature that tries to show User A's schedule to User B will fail or show nothing.
* **state**:
  * A set of blockLists with:
    * a `user`:User
    * a `blockedUsers` list of Users
* **actions**:
  * `blockUser (blocker: User, userToBlock: User)`
    * **requires** blocker is not userToBlock
    * **effects** If blocker exists as a user in `blockLists`, add `userToBlock` to `blockedUsers` for the entry of blockLists with user==blocker if userToBlock isn't already in the `blockedUsers` list. Otherwise create a new blockLists entry with user=blocker, and the list \[userToBlock]
  * `unblockUser (blocker: User, userToUnblock: User)`
    * **requires** `userToUnblock` is in the `blockedUsers` list for the entry in blockLists where `user` is `blocker`
    * **effects** Removes the pair `userToUnblock` from the `blockedUsers` list.
* **queries**:
  * `_isUserBlocked(primaryUser: User, secondaryUser: User): [Boolean]`
    * **effects** Returns true if `primaryUser` is a user in a blockLists entry and `secondaryUser` is in that entryâ€™s `blockedUsers` list.
  * `blockedUsers(user:User):Users[]`
    * **effects** returns blockedUsers for blockLists entry with `user`, and if one doesn't exist return an empty list
